# 构造函数的继承性
- 概念：子类具有父类的一部分特征（这部分相同的特征是从父类继承下来的），自己还有自己的特征
- 继承的方式：
  - 类式继承（call继承）
  - 原型继承
  - 寄生式组合继承
  - 拷贝继承
  - 对象继承
  - class继承
- 属性继承：
  - 调用父类，通过call把this变为子类的实例即可（call继承）
```
function Person (name,age){
        this.name = name;
        this.age = age
    }
    
    function Police(name,age){
        Person.call(this,name,age)//调用父类，通过call把this变为子类的实例即可（call继承）

    }
    Person.prototype.say=function(){
        alert('我的名字叫'+this.name)
    }
    let p1 = new Person('小王',18)
    let po1=new Police('小李',20)
    // p1.say()
    console.log(po1);
```
- 方法继承
  - 通过浅拷贝，把父类原型上的方法或者属性都**赋值**给子类的原型Object.assigin(子类.prototype,.父类prototype)
```
Object.assign(Police.prototype,Person.prototype);
Police.prototype.say=function(){
  alert('我是警察')
}
```
```
 Police.prototype = Person.prototype
    Police.prototype.say = function(){
        alert('我是警察')
    }
    p1.say()
    //此方法不可取，是赋值地址的原因，
如果修改子类，会影响到父类的方法
```
# Object.assigin(浅拷贝)
- 有两个的时候，右边的会赋值给左边，也就是说修改右边，并不会影响左边
- 如果有三的时候，中间的先赋值给最左边，最右边的再赋值给最左边的，此时有重复的属性，中间的属性会被覆盖掉但是中间的并不会改变
```
 let obj = {
        name:'阿里',
        age:10
    }//{name: "阿里", age: 10}
    let obj2 = {
        sex:'男',
        name:'zf',
        age:5
    }// 中间的没变{sex: "男", name: "zf", age: 5}
    let obj3 = {
        aa:8
    }//{aa: 8, sex: "男", name: "阿里", age: 10} 
    Object.assign(obj3,obj2,obj)
    console.log(obj3,obj2,obj);
```
  - 原型继承
    - 间接法（可以优化性能），先创建一个类，把父级的原型，赋值地址给新类的原型，让子类的原型等于新类的实例，此时修改子类只会修改新类的实例，并不会修改父类，而且子类也可以通过原型链找到父类的方法
```
function Paohui (){

}
Paohui.prototype = Person.prototype
Police.prototype = new Paohui
```
  - 直接把父类的实例赋值地址给子类的原型
```
Police.prototype=new Person
```
**注意这两种方法后，Police.prototype.constructor指向对象，需要手动修改为Police**

























  
    



  直接new的话name是undefined

