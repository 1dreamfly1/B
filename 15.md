# 小知识点
- Array.from()   把类数组转化为数组（ES6新规定）
- chceked checkbox多选的属性，点击有对钩返回值是布尔值ture
- 构造函数的里面（类）一般添加的是属性，方法一般放在构造函数的原型下
# 解构赋值：
- 数组的
  - 声明的时候左右两边的解构一定要保持一致,有解构的时候走解构，没有就走默认值，在没有就是undefined。
```
  let [x=5,y=2，z] = [1]
    console.log(x,y,Z);//1 2 undefined
```
  - 对象的
    - 在声明的时候使用块声明，块中放对象的key值，这里的key值一定要和解构对象的key值名字要一直
    - 如果要取别名，使用：号定义的名字即可，并且原key值已经访问不到了，要访问会报错，只能访问新定义的别名
    - 注意：传了对象那么就按照传的对象来解析，不会按照默认的来解析 
```
let objhdjksdjks = {
        type: "sug", 
        sa: "s_2",
        q: "猪肉为什么涨价厉害",
        s:"某炎生杀母猪"
    }    

     let {type:t,q,s} = objhdjksdjks;
    console.log(type,q,s);//报错
    console.log(t);//"sug"
```
```
let {name:x,age:y} = {name:'xxx',age:18}
console.log(x,y);//'xxx' 18
```
# call的使用方法
- Object.prototype.toString.call()所有的数据都有一个toString的方法，但是写法是不一样的，唯独Object的toString能够检测当前的数据类型，所以可以把this改变，达到我们的目的
- Array.prototype.toString.call()除了数组本身别的也都可以检测数据类型
- 为什么call this就能接到某个方法？
  - 因为这些方法内部使用的数据都是this
# class
```
{
    constructor(){
        //给自身添加属性或者方法，就必须要写constructor
    }
}  
```
```
class Preson{
    constructor(name){
        this.name =name
    }
    say(){
        console.log(this.name)
    }
}
//Preson.prototype.haha = 10(如果使用类那么不能直接修改类的原型地址，只能赋值简单类型的数据)
如果 key和val值是一样的，那么可以只写一个（对象的特性）
```
# 重写new
function Fn(name){
    this.name=name
}



  
