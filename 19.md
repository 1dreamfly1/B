# 正则前引案例
- 常规方法
```
//请你把下列字符串中的数字包括连续的数字挑出来，分别存到一个数组中
    let str = 'xh271y5rc74bg 326rgb087yr23n6x832321';
    let temp = ''
    let ary =[]
    for(let i = 0 ;i<str.length;i++){//如果当前的字符串为数字那么进行字符串拼接
        if( parseInt(str[i]) ){
            temp +=str[i]
        }
        else{//如果当前的字符串不是数字，那么就把之前拼接好的字符串放到数组中，并且清空这个字符串为了保证下次使用
            if(temp){
                ary.push(temp)
            temp = ''
            }           
        }
    }//如果最后一组也是数字确保不被拉下
    if(temp){
        ary.push(temp)
    }
    console.log(ary);    
```
- 正则方法
```
console.log(str.match(/\d+/g));
```
# 正则(没有用量词一定是一个字符)
- 含义： 专门用来检索**字符串**的一种规则（更擅长模糊范围的字符串）
- 表达式：
  - //(字面量写法) 里面放的是不带引号的字符串或者规则，并不是变量
  - new PegExp（构造函数的写法） （规则｛如果是字符串需要加引号，不加就是变量｝，修饰符）也就是说如果用变量只能用new PegExp
- 特性：
  - 懒惰：让他找一个绝对不会找第二个，让他找一堆绝对不会找第二堆
  - 贪婪：只要符合某个规则就不停的找，直到找不到为止
- 特殊转义符：
\d     ：代表了 0-9之间的数字  一个数字
\D     ：代表除了 0-9 的任意字符；
\w     ：代表了 数字 字母  下划线；
\W     ：代表除了 数字 字母 下划线 之外的任意字符 
\s     :代表一个空格字符
\S     :代表一个非空空格字符
\b     :代表一个边界符（只有英文才有，英文开头会有中间连着的不是英文也会有，最后一个英文后边也有）
\B     ：一个非边界符
^      ：代表以什么 字符 开头
$      ：代表以什么 字符 结尾
.      ：代表除了换行以外的所有字符（此时指的是有特殊含义的\n）
\n     ：代表换行
x|y    ：代表 x 或者 y
[]     : 代表 找任意一个字符  汉字：[\u4e00-\u9fa5] 英文：[a-zA-Z](因为ascll码的91-96是别的字符不是字母)
[ab]   ：代表a或者b
[^ab]  ：代表非ab
[a-z]  ：代表 a-z之间的任意字符
[^a-z] ：代表除了 小写字母
()     ：分组和提升优先级的意思
(?:)   ：非捕获 匹配
            (?=)
            (?!)
            (?=(?:))

量词元字符：一般都是用在了其他元字符的后边 
?   ： 代表 前边的字符出现 0或1次 {0,1}
+   :  代表 前边的字符出现 1或多次{1,}
*   :  代表 前边的字符出现 0或多次 {0,}
{n} ： 代表 前边的字符出现 n次
{n,m} ： 代表 前边的字符出现 n到m次
{n,} ： 代表 前边的字符出现 n到多次 最少n个

修饰符（放在正则后面） ：
i : 忽略大小写  ignoreCase
m : 多行匹配  mutiline
g : 全局匹配  global

  - \  转义字符 把正则中有特殊含义的字符 转成字符串本身（不再有任何特殊含义），转义字符转的是\后面的字符（字符串或者正则中使用都得需要加\取消特殊含义）
- 正则内置类方法
  - 正则.exec(字符串)：找到正则匹配的字符串（首次出现的字符而且就一次），并且放到数组中（返回值是这个数组）(使用修饰词g不起作用)(找不到是null)
```
    let str = 'xh271y5rc7/4bg 326rgb087yr23n6x832321';     
     console.log(/\dy/.exec(str));
     /*
     [0: "1y"  这是找到符合规则的字符
     groups: undefined 不用管
     index: 4 符合规则的字符首次出现的位置
     input: "xh271y5rc7/4bg 326rgb087yr23n6x832321" 原字符串
     length: 1  找到就是第一个，所以数组length就是1]
     */
```
  - 正则.test（字符串）：查看字符串中是否有规则匹配项，如果有就是返回true，否则就是false
# 字符串方法：
  - 字符串.match(正则)：找到正则匹配的字符串并把他们放到数组中（返回值是数组）(在正则中可以使用修饰词g，能起到作用)（找不到也是null）
```
 let str = 'xh271y5rc7\\4bg 326rgb\\5b087yr23n6x832321';  
    console.log(str.match(/\\\db/));
    /*
    [0: "\4b" 这是找到符合规则的字符
    groups: undefined 不用管
    index: 10 符合规则的字符首次出现的位置
    input: "xh271y5rc7\4bg 326rgb\5b087yr23n6x832321" 原字符串
    length: 1 
    console.log(str.match(/\\\db/g));//["\4b", "\5b"] length: 2
```
  - 字符串.replace（''或者放正则，'替换的字符串'或者放函数）
```
//过滤敏感词
    let str = '卧槽，你会不会玩，你个脑残,艹'
   let a = str.replace(/卧槽|脑残|艹/g,function($0){
     //函数的第一个参数就是每次匹配的字符，如果匹配多次那么会多次调用        
     let temp = ''
     for(let i=0;i<$0.length;i++){
         temp +='*'
     }
     return temp
    })
    console.log(a);
```
 - 字符串.trim
   - 只能去除字符串两边（最左边和最后边）的空格 
```
 let str  = '  a123 4a4 56 a897a  '   
   console.log(str.trim());
```
 - 分组（）
   - 一般用于match和replace
   - 分组数是从左到右边，具有提权的作用
     - 有分组的时候replace中的函数可以放多个参数
     ```
     replace(//,function($0,$1,$2...){
         $0：符合规则的字符
         $1：第一个分组
         $2: 第二个分组
         ... 直到分组读完就正常走索引、整个字符串、undefined

     })
     ```
   - （\d）+  这个\d代表最后一个数字，并不是第一个
# 手机号案例
```
        /*
        11位数字
        开头是1
        只能是数字
        第二位只能是3-9
        */
         let  str ='14345678912123'
         console.log(/^1[3-9]\d{9}$/.test(str));
```
# QQ
```
        /*
        不能以0开头
        都是数字
        最少6最多11
        */
         let  str ='11254209261'
         console.log(/^[1-9]\d{4,10}$/.test(str));
```














